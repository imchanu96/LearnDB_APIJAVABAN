--2개 테이블 조작?

--3개 테이블 조작?
SELECT P.PLAYER_NAME 선수명, P.POSITION, T.REGION_NAME, T.TEAM_NAME, S.STADIUM_NAME
FROM PLAYER P, TEAM T, STADIUM S
WHERE P.TEAM_ID = T.TEAM_ID
AND T.STADIUM_ID = S.STADIUM_ID
ORDER BY 선수명;

DESC PLAYER;
DESC TEAM;
DESC STADIUM;

SELECT * 
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO;

--내부 조인(INNER JOIN)이라고 부른다.
--동등 조인과 같다.
SELECT * 
FROM EMP E INNER JOIN DEPT D
ON E.DEPTNO = D.DEPTNO;

SELECT * 
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
AND E.SAL >= 2000;

SELECT * 
FROM EMP E INNER JOIN DEPT D
ON E.DEPTNO = D.DEPTNO
WHERE E.SAL >= 2000;

--다중 조인 ANSI 방법
SELECT P.PLAYER_NAME 선수명, P.POSITION, T.REGION_NAME, T.TEAM_NAME, S.STADIUM_NAME
FROM PLAYER P INNER JOIN TEAM T
ON P.TEAM_ID = T.TEAM_ID
JOIN STADIUM S
ON T.STADIUM_ID = S.STADIUM_ID
ORDER BY 선수명;


--1.포지션이 GK가 아닌 선수들
--그리고 팀이 삼성블루윙즈인 선수들에 대해 출력하시오
--선수명이 느린 순으로 출력
--
--선수명     백넘버     포지션     팀명

DESC PLAYER;
DESC TEAM;

SELECT P.PLAYER_NAME 선수명, P.BACK_NO 백넘버, P.POSITION 포지션, T.TEAM_NAME 팀명 
FROM PLAYER P INNER JOIN TEAM T
ON P.TEAM_ID = T.TEAM_ID
WHERE T.TEAM_NAME = '삼성블루윙즈'
AND P.POSITION <> 'GK'
ORDER BY P.PLAYER_NAME;

--2.소속팀이 가지고 있는 전용구장 중 좌석수가 50000 이상인 전용구장만 출력하시오
--좌석수가 큰 순으로 출력
--팀번호   팀명      경기장번호      경기장명   좌석수   
SELECT *
FROM TEAM;

SELECT *
FROM STADIUM;

SELECT T.TEAM_ID 팀번호, T.TEAM_NAME 팀명, S.STADIUM_ID 경기장번호, S.STADIUM_NAME 경기장명
    , S.SEAT_COUNT 좌석수
FROM TEAM T INNER JOIN STADIUM S
ON T.STADIUM_ID = S.STADIUM_ID
WHERE S.SEAT_COUNT >= 50000
ORDER BY 좌석수 DESC;

   
--3.사원들의 급여 중 1~2등급인 사원들의 정보를 출력하시오
--급여가 낮은 사원부터 출력되도록 하시오
--사원번호   사원명   직급      급여      급여등급   낮은값   큰값
SELECT *
FROM EMP;

SELECT *
FROM SALGRADE;

SELECT E.EMPNO 사원번호, E.ENAME 사원명, E.JOB 직급, E.SAL 급여, S.GRADE 급여등급
    ,S.LOSAL 낮은값, S.HISAL 큰값
FROM EMP E INNER JOIN SALGRADE S
ON E.SAL >= S.LOSAL
AND E.SAL <= S.HISAL
WHERE S.GRADE IN(1, 2)
ORDER BY E.SAL;


홈팀이 3점 이상 차이로 승라한 경기의 경기장 이름, 경기 일정,
홈팀 이름과 원정팀 이름 정보를 출력하시오
경기장ID   경기장명    경기날짜    팀명  상대팀명    HOME_SCORE  AWAY_SCORE    

SELECT *
FROM TEAM
ORDER BY TEAM_ID;

SELECT *
FROM SCHEDULE
WHERE HOME_SCORE - AWAY_SCORE >= 3;

SELECT *
FROM STADIUM;

-- 내가 푼 해답
SELECT S.STADIUM_ID 경기장ID, S.STADIUM_NAME 경기장명
    , TO_CHAR(TO_DATE(SC.SCHE_DATE), 'YYYY-MM-DD') 경기일자
    , HOMET.TEAM_NAME 팀명, AWAYT.TEAM_NAME 상대팀명, SC.HOME_SCORE, SC.AWAY_SCORE
FROM SCHEDULE SC INNER JOIN STADIUM S
ON SC.STADIUM_ID = S.STADIUM_ID
JOIN TEAM HOMET
ON SC.HOMETEAM_ID = HOMET.TEAM_ID
JOIN TEAM AWAYT
ON SC.AWAYTEAM_ID = AWAYT.TEAM_ID
WHERE SC.HOME_SCORE - SC.AWAY_SCORE >= 3;

-- 강사님이랑 같이 풀어본 해답
SELECT *
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'TEAM'
OR TABLE_NAME = 'STADIUM'
OR TABLE_NAME = 'SCHEDULE';

SELECT *
FROM SCHEDULE;

SELECT *
FROM STADIUM;
--관계 먼저 살펴봄
SELECT *
FROM STADIUM S, SCHEDULE SC
WHERE S.STADIUM_ID = SC.STADIUM_ID;
--보여줘야 하는 컬럼값 넣음
--경기장ID   경기장명    경기날짜    팀명  상대팀명    HOME_SCORE  AWAY_SCORE  
SELECT S.STADIUM_ID, S.STADIUM_NAME, SC.SCHE_DATE, SC.HOMETEAM_ID, SC.AWAYTEAM_ID
    ,SC.HOME_SCORE, SC.AWAY_SCORE
FROM STADIUM S, SCHEDULE SC
WHERE S.STADIUM_ID = SC.STADIUM_ID
AND SC.HOME_SCORE >= SC.AWAY_SCORE + 3;
-- 홈팀ID와 어웨이팀ID를 이름으로 변경한다.
SELECT *
FROM TEAM;

SELECT S.STADIUM_ID, S.STADIUM_NAME, SC.SCHE_DATE, T.TEAM_NAME, AT.TEAM_NAME
    ,SC.HOME_SCORE, SC.AWAY_SCORE
FROM STADIUM S, SCHEDULE SC, TEAM T, TEAM AT
WHERE S.STADIUM_ID = SC.STADIUM_ID
AND SC.HOME_SCORE >= SC.AWAY_SCORE + 3
AND SC.HOMETEAM_ID = T.TEAM_ID
AND SC.AWAYTEAM_ID = AT.TEAM_ID;

-- 이제 순서에 맞게 바꾼다.
SELECT S.STADIUM_ID, S.STADIUM_NAME, SC.SCHE_DATE, T.TEAM_NAME, AT.TEAM_NAME
    ,SC.HOME_SCORE, SC.AWAY_SCORE
FROM STADIUM S, SCHEDULE SC, TEAM T, TEAM AT
WHERE S.STADIUM_ID = SC.STADIUM_ID
AND SC.HOMETEAM_ID = T.TEAM_ID
AND SC.AWAYTEAM_ID = AT.TEAM_ID
AND SC.HOME_SCORE >= SC.AWAY_SCORE + 3;


SELECT E.ENAME, D.DNAME
FROM EMP E CROSS JOIN DEPT D
ORDER BY E.ENAME;

ANSI 외부 조인
OUTER 조인

CREATE TABLE DEPT01(
    DEPTNO NUMBER,
    DNAME VARCHAR2(100)
);

INSERT INTO DEPT01
VALUES(10, 'ACCOUNTING');

INSERT INTO DEPT01
VALUES(20, 'RESERCH');

CREATE TABLE DEPT02
    AS
SELECT *
FROM DEPT01;

INSERT INTO DEPT02
VALUES(10, 'ACCOUNTING');

INSERT INTO DEPT02
VALUES(30, 'SALES');

SELECT *
FROM DEPT01;

SELECT *
FROM DEPT02;

SELECT * 
FROM DEPT01 D, DEPT02 D2
WHERE D.DEPTNO = D2.DEPTNO;

SELECT * 
FROM DEPT01 D, DEPT02 D2
WHERE D.DEPTNO = D2.DEPTNO(+);
-- 왼쪽 정보 
SELECT * 
FROM DEPT01 D LEFT OUTER JOIN DEPT02 D2
ON D.DEPTNO = D2.DEPTNO;
-- 오른쪽 정보
SELECT * 
FROM DEPT01 D RIGHT OUTER JOIN DEPT02 D2
ON D.DEPTNO = D2.DEPTNO;
-- 전부다
SELECT * 
FROM DEPT01 D FULL OUTER JOIN DEPT02 D2
ON D.DEPTNO = D2.DEPTNO;

--LEFT
--ANSI 표준 조인으로만 구하시오
--1. 스타디움에 등록된 운동장중에 홈팀이 없는 경기장도 있다
--홈팀이 없는 경기장을 출력하시오
--경기장명    팀명
SELECT *
FROM STADIUM;

SELECT *
FROM TEAM;

SELECT S.STADIUM_NAME 경기장명, T.TEAM_NAME 팀명
FROM STADIUM S LEFT OUTER JOIN TEAM T
ON S.HOMETEAM_ID = T.TEAM_ID
WHERE T.TEAM_NAME IS NULL;

--RIGHT
--2. DEPT에 등록된 부서 중에 사원이 없는 부서를 출력하시오
--부서명     사원명

SELECT *
FROM DEPT;

SELECT *
FROM EMP
WHERE DEPTNO IS NULL;

SELECT D.DNAME 부서명, E.ENAME 사원명
FROM DEPT D RIGHT OUTER JOIN EMP E
ON E.DEPTNO = D.DEPTNO
WHERE E.DEPTNO IS NULL;

SELECT D.DNAME 부서명, E.ENAME 사원명
FROM EMP E RIGHT OUTER JOIN DEPT D
ON E.DEPTNO = D.DEPTNO
WHERE E.DEPTNO IS NULL;

--???????????
--3.상사들 중에 아랫사원들의 정보와 
--아랫사원이 존재하지 않는 사원들을 출력하시오
--상사명      아랫사원명

SELECT *
FROM EMP;

SELECT *
FROM EMP
WHERE MGR = 7499;

SELECT M.ENAME 상사명, E.ENAME 아랫사원명
FROM EMP E FULL OUTER JOIN EMP M
ON M.EMPNO = E.MGR;

--MARTIN의 부서위치는 어디인가?
SELECT ENAME, DEPTNO
FROM EMP
WHERE ENAME ='MARTIN';

SELECT *
FROM DEPT
WHERE DEPTNO = 30;

SELECT E.ENAME, D.LOC
FROM EMP E INNER JOIN DEPT D
ON E.DEPTNO = D.DEPTNO
WHERE E.ENAME = 'MARTIN';

--서브 쿼리?                                 수행순서
SELECT LOC                                  --5
FROM DEPT                                   --1
WHERE DEPTNO = (SELECT DEPTNO               --4 수행 다하면 ENAME에 대한 DEPTNO만 남기고 종료
                FROM EMP                    --2
                WHERE ENAME = 'MARTIN');    --3

-- 1.SMITH와 같은 부서에서 근무하는 사원의 이름과 부서의 번호를 출력하시오
--사원번호    사원명     DEPTNO
SELECT EMPNO 사원번호, ENAME 사원명, DEPTNO
FROM EMP
WHERE DEPTNO = (SELECT DEPTNO
                FROM EMP
                WHERE ENAME = 'SMITH')
AND ENAME <> 'SMITH';
                
-- 2.FORD와 동일한 직급을 가진 사원을 출력하시오
--   전체 컬럼
   
SELECT JOB
FROM EMP
WHERE ENAME = 'FORD';

SELECT *
FROM EMP
WHERE JOB = (SELECT JOB
            FROM EMP
            WHERE ENAME = 'FORD');

--3.FORD의 급여와 동일하거나 더 많이 받는 사원명의 급여를 출력하시오
--사원번호      급여      

SELECT *
FROM EMP
WHERE ENAME = 'FORD';

SELECT EMPNO 사원번호, SAL 급여
FROM EMP
WHERE SAL >= (SELECT SAL
              FROM EMP
              WHERE ENAME = 'FORD');

--4.정남일 선수가 소속된 팀의 선수들에 대한 정보를 표시하시오
--조인문
--백넘버를 내림차순으로 하시오
--팀ID      팀명       선수컬럼전부         
SELECT *
FROM PLAYER
WHERE PLAYER_NAME = '정남일';

SELECT *
FROM PLAYER
WHERE TEAM_ID = 'K07';

SELECT *
FROM TEAM
WHERE TEAM_ID = 'K07';

SELECT P.TEAM_ID 팀ID, T.TEAM_NAME 팀명, P.*
FROM PLAYER P INNER JOIN TEAM T
ON P.TEAM_ID = T.TEAM_ID
JOIN PLAYER P2
ON P.TEAM_ID = P2.TEAM_ID
WHERE P2.PLAYER_NAME = '정남일'
ORDER BY P.BACK_NO DESC;

--4_2.정남일 선수가 소속된 팀의 선수들에 대한 정보를 표시하시오
--서브쿼리
--선수번호     선수명   포지션     백넘버
SELECT *
FROM PLAYER;

SELECT PLAYER_ID 선수번호, PLAYER_NAME 선수명, POSITION 포지션, BACK_NO 백넘버
FROM PLAYER
WHERE  TEAM_ID = (SELECT TEAM_ID
                 FROM PLAYER
                 WHERE PLAYER_NAME = '정남일')
ORDER BY BACK_NO DESC;
                   
--5.선수들 중에서 키가 평균 이하인 선수들의 정보를 조회하시오
--선수명   포지션   키      백넘버
SELECT *
FROM PLAYER;

SELECT AVG(HEIGHT) 키
FROM PLAYER;

SELECT PLAYER_NAME 선수명, POSITION 포지션, HEIGHT 키, BACK_NO 백넘버
FROM PLAYER
GROUP BY POSITION
HAVING AVG(HEIGHT);

SELECT PLAYER_NAME 선수명, POSITION 포지션, HEIGHT 키, BACK_NO 백넘버
FROM PLAYER
WHERE HEIGHT <= (SELECT AVG(HEIGHT)
                FROM PLAYER);



--조인시 테이블 컬럼값 표현하기

SELECT T.TEAM_ID AS 팀ID, T.TEAM_NAME AS 팀명
    ,P.PLAYER_ID, P.PLAYER_NAME ,P.TEAM_ID ,P.E_PLAYER_NAME
    ,P.NICKNAME,P.JOIN_YYYY,P.POSITION,P.BACK_NO
    ,P.NATION,P.BIRTH_DATE,P.SOLAR,P.HEIGHT,P.WEIGHT
FROM TEAM T JOIN PLAYER P
ON T.TEAM_ID = P.TEAM_ID
WHERE P.TEAM_ID = ( SELECT TEAM_ID
                    FROM PLAYER
                    WHERE PLAYER_NAME = '정남일')
ORDER BY P.BACK_NO;     

--SELECT *
--FROM TEAM T JOIN PLAYER P
--ON T.TEAM_ID = P.TEAM_ID
--WHERE P.TEAM_ID = ( SELECT TEAM_ID
--                    FROM PLAYER
--                    WHERE PLAYER_NAME = '정남일')
--ORDER BY P.BACK_NO;

-- 이건 왜 안될까?, 명시한 컬럼과 *가 표현하는 컬럼값이 중복이 되어 안된다고 한다. 
SELECT T.TEAM_ID, T.TEAM_NAME, *
FROM TEAM T JOIN PLAYER P
ON T.TEAM_ID = P.TEAM_ID
WHERE P.TEAM_ID = ( SELECT TEAM_ID
                    FROM PLAYER
                    WHERE PLAYER_NAME = '정남일')
ORDER BY P.BACK_NO;
                
--별칭을 통해 구분을 해서 별칭.*을 통해 가능하다
--하지만 유지보수가 가능하게 한방에 한번에 편하게는 (현업에는)없다
SELECT T.TEAM_ID AS 팀ID, T.TEAM_NAME AS 팀명
    ,P.*
FROM TEAM T JOIN PLAYER P
ON T.TEAM_ID = P.TEAM_ID
WHERE P.TEAM_ID = ( SELECT TEAM_ID
                    FROM PLAYER
                    WHERE PLAYER_NAME = '정남일')
ORDER BY P.BACK_NO;   